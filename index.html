<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>The Jungle B</title>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
		<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

		<link rel="stylesheet" type="text/css" href="styles.css" />
	</head>
	<body>
		<div id="loading-screen">
			<div class="loader"></div>
			<img class="logo" src="logo.svg" alt="Logo" />
			<p id="loading-text">Initializing...</p>
		</div>

		<!-- Checkbox for Hachi -->
		<div id="hachiCheckboxContainer">
			<input type="checkbox" id="hachiCheckbox" onclick="toggleDeviceName()" />
		</div>
		<!-- Console output-->
		<div id="consoleOutput"></div>
		<div id="logoSpace">
			<img class="logo" src="logo.svg" alt="Logo" />
		</div>
		<div id="avatarBTdiv">
			<div class="top-section">
				<!-- Listen Button (left half) -->
				<button id="listenButton" class="button listen-button" onclick="forward_Sound.play(), wakeLock(),listenFunction()">
					<span class="material-symbols-outlined" style="vertical-align: middle;">hearing</span>Listen
				</button>

				<!-- Toggle Switch -->
				<div id="toggleContainer" style="display: none;">
					<span id="buroToggle">
						<span class="material-symbols-outlined" style="vertical-align: middle;">accessibility_new</span>
						<span class="label">Buro</span>
					</span>
					<label class="switch">
						<input type="checkbox" id="toggleSwitch" onchange="forward_Sound.play()" />
						<span class="slider"></span>
					</label>
					<span id="hachiToggle">
						<span class="material-symbols-outlined" style="vertical-align: middle;">pets</span>
						<span class="label">Hachi</span>
					</span>
				</div>

				<!-- Interact Button (right half) -->
				<button
					id="interactButton"
					class="button interact-button"
					onclick="forward_Sound.play(),wakeLock(), interactFunction()"
				>
					<span class="material-symbols-outlined" style="vertical-align: middle;">back_hand</span>Interact
				</button>
			</div>
			<div class="bottom-section">
				<!-- Connect Button. -->
				<button
					id="connectButton"
					class="button"
					style="display: none;"
					disabled
					onclick="connecting_Sound.play(), displayText(String(this.lastChild.textContent.trim()))"
				>
					<span class="material-icons" style="vertical-align: middle;">bluetooth_searching</span> Connect to Avatar
				</button>
			</div>
		</div>
		<!-- Movement tracking-->
		<div id="avatarCanvas"></div>
		<!-- Status-->
		<div id="currentLocation"></div>
		<!-- Message>-->
		<div id="messageDisplayDiv"></div>
		<script>
			//Script for pairing with Avatar_BT
			let characteristic;
			let isConnected = false; // Track connection state
			let device; // Declare device variable.
			var message;
			let partMoving = "none";
			let directionMoving = "none";
			//let patternMovement ="none";
			var blueToothStatus = "Offline";
			var streetName = "Unknown";
			var deviceName ="Unknown";
			let labels = ["EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY"];
			let moveSource = null;
			let movePatterns = null;
			let sentenceSource = null;
			let tagSource = 'tags.json';
			let checkpointsSource = 'points.json';
			let characterName = "";
			let interactionMode = "_load";

			var connecting_Sound = new Howl({src: ['audio/ui_loading.mp3'],
			onloaderror: function(error) {console.error('Error loading audio:', error);},});
			var bgm_Sound=new Howl({src:['audio/bgm.mp3'],loop:true,volume:0.2});

			async function initializeSounds() {
				try {
					const sounds = await fetchJSONFile('sounds.json', window.sounds); // Load JSON file
					if (sounds) {
						const totalSounds = Object.keys(sounds).length;
						let loadedSounds = 0;

						// Function to track loaded sounds
						function soundLoaded() {
							loadedSounds++;

							const percentage = Math.round((loadedSounds / totalSounds) * 100);
							document.getElementById('loading-text').textContent = `Loading resources... ${percentage}%`;

							// Check if all sounds are loaded
							if (loadedSounds === totalSounds) {
								console.log('All resources loaded');
								hideLoadingScreen(); // Hide loading screen when all sounds are loaded
							}
						}

						// Initialize each sound using Howler
						for (const key in sounds) {
							if (sounds.hasOwnProperty(key)) {
								window[key] = new Howl({
									src: [sounds[key].src],
									volume: 0.4,
									onload: soundLoaded, // Call soundLoaded() when sound is loaded successfully.
									onloaderror: function(error) {
										console.error('Error loading audio resources:', error);
									},
									onstop: function(id) {
										console.log(`Sound with key '${key}' and ID ${id} stopped.`);
										console.log('Playback position:', this.seek());
										console.trace(); // To see where the stop() was called from
									}								
								});
							}
						}
					} else {
						console.error('Failed to load audio resources.');
						hideLoadingScreen(); // Hide loading screen on failure to load sounds
					}
				} catch (error) {
					console.error('Error initializing resources:', error);
					hideLoadingScreen(); // Hide loading screen on error
				}
			}

			// Function to hide the loading screen
			function hideLoadingScreen() {
				var loadingScreen = document.getElementById('loading-screen');
				//loadingScreen.style.display = 'none';
				loadingScreen.classList.add('hidden'); // Add the 'hidden' class to trigger the fade-out effect
			}

			function checkVariables() {
				// Check if latitude, longitude, and weatherDescription are not null
				if (latitude !== null && longitude !== null) {
					connectButton.disabled = false;
					//initializeSounds();
				} else {
					// If any variable is still null, wait for a short delay and check again
					setTimeout(checkVariables, 1000);
				}
			}

			let sessionId = '';
			function generateSessionId() {
				for (let i = 0; i < 6; i++) {
					sessionId += Math.random().toString(36).charAt(2); // Generates a random alphanumeric character
				}
				console.log("Session id: "+ sessionId)
				return sessionId;
			}

			let user_ip; // Declare user_ip in the global scope
			async function getUserIP() {
				try {
					const response = await fetch('https://api.ipify.org?format=json');
					const data = await response.json();
					return data.ip;
				} catch (error) {
					console.error('Error fetching IP address:', error);
					return null;
				}
			}

			async function storeUserIP() {
				user_ip = await getUserIP(); // Assign to the global user_ip
				if (user_ip) {
					return user_ip; // Returning the IP is still a good practice.
				} else {
					return null;
				}
			}

			// Event listener for when the page's DOM content is fully loaded
			document.addEventListener('DOMContentLoaded', function() {
				console.log("Initializing resources.");
				initializeSounds();
				checkVariables();
				storeUserIP().then(() => {
				if (user_ip) {
					console.log('User IP:', user_ip);
				}
				});
				generateSessionId();
			});

			function toggleDeviceName() {
				var checkbox = document.getElementById("hachiCheckbox");
				if (checkbox.checked) {
					deviceName = "hachi_BT";
					console.log("Loading settings for "+ deviceName);
					interactionMode="_int";
					moveSource = 'hachi_moves.json';
					movePatterns = 'hachi_patterns.json';
					sentenceSource = 'hachi_sentences.json';
					characterName = "Hachi";
					initializeSounds();
				} else {
					deviceName = "avatar_BT";
					console.log("Loading settings for "+ deviceName);
					interactionMode="_int";
					moveSource = 'avatar_moves.json';
					movePatterns = 'avatar_patterns.json';
					sentenceSource = 'avatar_sentences.json';
					characterName = "Buro";
					initializeSounds();
				}
			}

			var listenClient = null;

			function interactFunction() {
				listenClient = false;
				// Hide the Listen button
				document.getElementById('listenButton').style.display = 'none';
				// Hide the Interact button
				document.getElementById('interactButton').style.display = 'none';
				// Show the Connect button
				document.getElementById('connectButton').style.display = 'inline-block';
			}

			function listenFunction() {
				listenClient = true;
				// Hide the Interact button
				document.getElementById('interactButton').style.display = 'none';
				// Show toggle
				document.getElementById('toggleContainer').style.display = 'flex';
				document.getElementById("toggleSwitch").click();
			}

			async function connectToDevice() {
				try {
					if (!isConnected) {
						// Request Bluetooth device
						device = await navigator.bluetooth.requestDevice({
							filters: [{ services: ["4fafc201-1fb5-459e-8fcc-c5c9c331914b"] }],
						});
						// Connect to the selected device
						const server = await device.gatt.connect();
						// Get UART service
						const service = await server.getPrimaryService("4fafc201-1fb5-459e-8fcc-c5c9c331914b");
						// Get UART characteristic
						characteristic = await service.getCharacteristic("beb5483e-36e1-4688-b7f5-ea07361b26a8");
						// Start notifications for the characteristic
						await characteristic.startNotifications();
							// Get the device name
						deviceName = device.name;

						if (deviceName === "hachi_BT") {
							console.log("Loading settings for Hachi_BT");
							interactionMode="_int";
							labels = ["EMPTY", "EMPTY", "EMPTY", "EMPTY", "HEAD", "FRONT LEG", "TAIL", "BACK LEG", "EMPTY", "EMPTY"];
							moveSource = 'hachi_moves.json';
							movePatterns = 'hachi_patterns.json';
							sentenceSource = 'hachi_sentences.json';
							tagSource = 'tags.json';
							initializeSounds();
							document.getElementById("hachiCheckbox").click();
							characterName = "Hachi";
							window[characterName + "_Sound"].play();
							//bgm_Sound.play(); No song
							notification_Sound.play();
						} else {
							console.log("Loading settings for Avatar_BT");
							interactionMode="_int";
							labels = ["LEFT ARM", "RIGHT ARM", "HEAD", "LEFT LEG", "RIGHT LEG", "LEFT FOOT", "RIGHT FOOT", "RIGHT HAND", "LEFT HAND", "EYES", "MOUTH"];
							moveSource = 'avatar_moves.json';
							movePatterns = 'avatar_patterns.json';
							sentenceSource = 'avatar_sentences.json';
							tagSource = 'tags.json';
							initializeSounds();
							characterName = "Buro";
							window[characterName + "_Sound"].play();
							//bgm_Sound.play(); No song
							notification_Sound.play();
						}
						// Listen for characteristic value changes
						characteristic.addEventListener("characteristicvaluechanged", handleCharacteristicValueChanged);
						// Update UI
						document.getElementById("connectButton").innerHTML = '<span class="material-icons" style="vertical-align: middle;">bluetooth_connected</span> Disconnect Avatar';
						isConnected = true;
							startDetectMovement = true;
							blueToothStatus = "Online";
					} else {
						// Disconnect from the device
						await characteristic.stopNotifications();
						await device.gatt.disconnect();
						isConnected = false;
						document.getElementById("connectButton").innerHTML = '<span class="material-icons" style="vertical-align: middle;">bluetooth_searching </span> Connect to Avatar';
						// Set all potValues to 0
						setTimeout(function() {
							startDetectMovement = false;
							potValues = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
							blueToothStatus = "Offline";
							bgm_Sound.stop();
						}, 4000);
					}
				} catch (error) {
					console.error("Error connecting/disconnecting to device: " + error);
				}
			}
			// Attach click event listener to button.
			document.getElementById("connectButton").addEventListener("click", connectToDevice);

			// Function to handle incoming data from UART
			function handleCharacteristicValueChanged(event) {
				const value = event.target.value;
				// Convert the received data to a string
				const textDecoder = new TextDecoder();
				const decodedValue = textDecoder.decode(value);
				// Pass the received data to Processing sketch
				receiveData(decodedValue);
			}
			// Function to receive data from JavaScript
			function receiveData(data) {
				if (window.receiveDataFromSerial) {
					window.receiveDataFromSerial(data);
				} else {
					console.error("Processing sketch not initialized.");
				}
			}

			function wakeLock() {
				if ('wakeLock' in navigator) {
							navigator.wakeLock.request('screen').then(() => {
								console.log('Screen wake lock activated');
							}).catch((err) => {
								console.error('Failed to activate wake lock:', err);
							});
						} else {
							console.error('Wake lock API not supported.');
						}
			}

			function redirectConsoleToDiv() {
				const consoleOutputDiv = document.getElementById('consoleOutput');
				if (!consoleOutputDiv) {
					console.error("Div for console output not found.");
					return;
				}

				// Save the original console.log and console.error functions.
				const originalConsoleLog = console.log;
				const originalConsoleError = console.error;
				const logMessages = []; // Array to store log messages

				// Generic function to handle logging
				function handleLog(type, originalFunction, ...args) {
					originalFunction(...args);
					const message = args.map(arg => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join(' ');
					logMessages.push(`<strong>CONSOLE ${type}:</strong> ${message}`);
					updateConsoleOutput();

					// Send log/error to Google Sheet
					// sendToSheet(type, message);
				}

				// Function to send data to Google Sheet
				function sendToSheet(type, message) {
					const timestamp = new Date().toISOString();
					const scriptURL = `https://script.google.com/macros/s/AKfycbxV_7DD1zilVjmNXQP3zHgtqFMY6ekcsD8-ginnUcUFXq6x_j-vxW6sFftfDCbZCZTq5w/exec`;
					const params = new URLSearchParams({
						timestamp,
						user_ip,
						sessionId,
						agent: deviceName + interactionMode,
						movement: `${potValues}`,
						type,
						location: `${latitude},${longitude}`,
						message,
						messageID
					});

					fetch(`${scriptURL}?${params.toString()}`, {
						method: 'GET',
						mode: 'no-cors',
					}).catch(err => originalConsoleError('Failed to log to sheet:', err));
				}

				// Override console.log and console.error
				console.log = (...args) => handleLog("DEBUG", originalConsoleLog, ...args);
				console.error = (...args) => handleLog("ERROR", originalConsoleError, ...args);

				// Function to update the console output div
				function updateConsoleOutput() {
					// Get the last two messages
					const lastTwoMessages = logMessages.slice(-2);

					// Update the output div
					consoleOutputDiv.innerHTML = lastTwoMessages
						.map(msg => `<div class="log">${msg}</div>`)
						.join('');
				}
			}


			// Call the function to redirect console.log and console.error to the div
			redirectConsoleToDiv();
		</script>

		<script>
			var latitude;
			var longitude;
			let speed;
			var distEachOther = 0;
			let directionText = "Not moving"

			function getCurrentLocation() {
				if (navigator.geolocation) {
					const options = {
						enableHighAccuracy: true,
					};
					let previousPosition = null;
					let totalDistance = 0;
					navigator.geolocation.watchPosition(
						function (position) {
							latitude = position.coords.latitude.toFixed(6); // Store latitude globally
							longitude = position.coords.longitude.toFixed(6); // Store longitude globally
							//console.log("Location is longitude: " + longitude + " latitude: "+ latitude );
							const speedThreshold = 0.2; // Threshold for considering the user as significantly moving (in meters per second)
							speed = position.coords.speed || 0; // Speed in meters per second
							// Reset total distance if speed is less than threshold
							if (speed < speedThreshold) {
								totalDistance = 0;
							} else if (previousPosition) {
								const distance = calculateDistance(
									previousPosition.coords.latitude,
									previousPosition.coords.longitude,
									position.coords.latitude,
									position.coords.longitude
								);
								totalDistance += distance;
							}
							previousPosition = position;
							let heading = position.coords.heading || 0; // Heading in degrees
							// Determine direction text based on heading

							if (speed >= speedThreshold) {
								if (heading >= 337.5 || heading < 22.5) {
									directionText = "north";
								} else if (heading >= 22.5 && heading < 67.5) {
									directionText = "northeast";
								} else if (heading >= 67.5 && heading < 112.5) {
									directionText = "east";
								} else if (heading >= 112.5 && heading < 157.5) {
									directionText = "southeast";
								} else if (heading >= 157.5 && heading < 202.5) {
									directionText = "south";
								} else if (heading >= 202.5 && heading < 247.5) {
									directionText = "southwest";
								} else if (heading >= 247.5 && heading < 292.5) {
									directionText = "west";
								} else if (heading >= 292.5 && heading < 337.5) {
									directionText = "northwest";
								}
							} else {
								directionText = "somewhere";
							}

							if (blueToothStatus=="Online"){
								checkCheckpoints();
							}

							// Update the HTML element with different navigation variables
							document.getElementById("currentLocation").innerHTML =
								"<strong><span class='material-icons' style='vertical-align: middle;'>bluetooth</span> Bluetooth:</strong> " + blueToothStatus + "<br>" +
								" <strong><span class='material-icons' style='vertical-align: middle;'>place</span> Latitude:</strong> " + latitude +
								"<strong> Longitude:</strong> " + longitude + "<br>" +
								"<strong><span class='material-icons' style='vertical-align: middle;'>location_city</span> Nearest street:</strong> " + streetName +
								" <strong><span class='material-icons' style='vertical-align: middle;'>pets</span><span class='material-icons' style='vertical-align: middle;'>person</span> Separation :</strong> " + distEachOther.toFixed(2) +" m" + "<br>" +
								" <strong><span class='material-icons' style='vertical-align: middle;'>explore</span> Direction:</strong> " + directionText +
								" <strong><span class='material-icons' style='vertical-align: middle;'>speed</span> Speed:</strong> " + speed.toFixed(2) + "ms/s" + "<br>" +
								" <strong><span class='material-icons' style='vertical-align: middle;'>directions_walk</span> Distance Walked: </strong> " + totalDistance.toFixed(2) +
								" m <strong>Avatar Actions:</strong> "+ partMoving + " " + directionMoving;
						},
						function (error) {
							console.error("Error getting current location: ", error);
						},
						options
					);
				} else {
					console.error("Geolocation is not supported by this browser.");
				}
			}

			// Function to calculate the distance between two coordinates using Haversine formula.
			function calculateDistance(lat1, lon1, lat2, lon2) {
				const earthRadius = 6371e3; // Earth radius in meters
				const phi1 = (lat1 * Math.PI) / 180; // Latitude in radians
				const phi2 = (lat2 * Math.PI) / 180; // Latitude in radians
				const deltaPhi = ((lat2 - lat1) * Math.PI) / 180;
				const deltaLambda = ((lon2 - lon1) * Math.PI) / 180;
				const a =
					Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				const distance = earthRadius * c; // Distance in meters
				return distance;
			}
			getCurrentLocation();
		</script>

		<script type="text/javascript">
				// Processing 4 sketch to visualize movements of the Avatar.
				let numPotentiometers = 11;
				let potValues;
				let lineColors;
				let backgroundColors;
				let isMovingUp = false;
				let isMovingDown = false;
				var previousPotValues = new Array(numPotentiometers);
				const cooldownDuration = 500; // 1 second
				let detectMovement = true;
				let startDetectMovement = false;
				let tagID = 0;

				function setup() {
					var avatarBTCanvas = createCanvas(windowWidth, windowHeight * 0.35);
					avatarBTCanvas.parent("avatarCanvas");
					potValues = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Initialize potValues array with default values
					lineColors = new Array(numPotentiometers);
					backgroundColors = new Array(numPotentiometers);
					setupColors();
					setupBackgroundColors();
				}
				function draw() {
					background(255);
					let lineHeight = height / numPotentiometers;
					let labelSize = min(width, height) * 0.03; // Responsive font size for labels
					for (let i = 0; i < numPotentiometers; i++) {
						let lineY = i * lineHeight + lineHeight / 2;
						// Draw the background rectangle
						noStroke();
						fill(backgroundColors[i]);
						rect(0, i * lineHeight, width, lineHeight);
						// Draw the line with different color for each
						strokeWeight(30);
						stroke(lineColors[i]);
						line(0, lineY, map(potValues[i], 0, 1024, 0, width * 0.55), lineY);
						// Display the corresponding value to the left of the line
						noStroke();
						fill(255);
						textFont("Roboto");
						textAlign(RIGHT, CENTER);
						textSize(labelSize);
						text(int(potValues[i]), map(potValues[i], 0, 1024, 0, width * 0.55) - 10, lineY);
					}
					// Draw vertical labels on the right side
					textAlign(RIGHT, CENTER);
					let labelFontSize = min(width, height) * 0.04; // Responsive font size for labels
					textFont("Roboto");
					textSize(labelFontSize);
					fill(255); // Set text color to white
					for (let i = 0; i < numPotentiometers; i++) {
						text(labels[i], width * 0.9, i * lineHeight + lineHeight / 2);
					}
					// Detect movement and display corresponding text
					if (startDetectMovement){
						checkMovement();
					}
				}

				const alpha = 1; // Adjust to control smoothing (0 = no change, 1 = instant change)

				function lowPassFilter(currentValue, newValue) {
					return alpha * newValue + (1 - alpha) * currentValue;
				}

				// Function to receive data from JavaScript
				function receiveData(data) {
					let cleanData = data.trim();
    				let values = cleanData.split(",");
					//console.log(values);
					if (values.length === numPotentiometers) { // Check if the length of values is 11
						for (let i = 0; i < values.length; i++) {
							potValues[i] = parseFloat(lowPassFilter(potValues[i] || parseFloat(values[i]), parseFloat(values[i])).toFixed(1));						}
					}
				}

				let previousMovements = {};

				// Function to check if two objects have the same keys and values..
				function objectsEqual(obj1, obj2) {
					const keys1 = Object.keys(obj1);
					const keys2 = Object.keys(obj2);

					if (keys1.length !== keys2.length) {
						return false;
					}

					for (let key of keys1) {
						if (obj1[key] !== obj2[key]) {
							return false;
						}
					}

					return true;
				}

// Define variables for detecting movement in different body parts

let keysToForget = new Set(); // Stores movement labels that were just released.
let digitalReleaseTimers = new Map();
const RELEASE_PERSISTENCE_MS = 1000;

function handleMovement() {
    let movements = {};
    const movementThreshold = 25;

    // Configuration: Define parts that use DIGITAL logic
    const digitalParts = [
        "LEFT FOOT", "RIGHT FOOT", 
        "RIGHT HAND", "LEFT HAND", 
        "EYES", "MOUTH"
    ];

    // Mapping between labels and movements 
    let labelMovements;
    labelMovements = {
        "LEFT ARM": "leftArmMoving", "RIGHT ARM": "rightArmMoving",
        "HEAD": "headMoving", "LEFT LEG": "leftLegMoving",
        "RIGHT LEG": "rightLegMoving", "LEFT FOOT": "leftFootPressed",
        "RIGHT FOOT": "rightFootPressed", "RIGHT HAND": "rightHandTouched",
        "LEFT HAND": "leftHandTouched", "EYES": "eyesTouched",
        "MOUTH": "mouthTouched"
    };

    // --- NEW: CLEANUP KEYS FLAGGED IN THE PREVIOUS CYCLE ---
    if (digitalReleaseTimers.size > 0) {
        // We only clear timers here if the key has been removed by the timer itself.
        // The deletion from previousMovements is handled asynchronously by the setTimeout,
        // so no explicit cleanup of previousMovements is needed here.
    }

    // 1. Process All Sensors
    for (let i = 0; i < numPotentiometers; i++) {
        let label = labels[i];
        let movement = labelMovements[label];

        if (movement === null || movement === undefined) {
            continue;
        }

        if (digitalParts.includes(label)) {
            // SCENARIO 1: DIGITAL Inputs - REPORT ACTIVE STATE OR TRANSITIONAL RELEASE
            
            let isCurrentlyActive = (potValues[i] > 0); 
            let wasPreviouslyActive = previousMovements[movement] === true; 
            
            // If the state has changed or is still active, clear any pending release timer
            if (digitalReleaseTimers.has(movement)) {
                clearTimeout(digitalReleaseTimers.get(movement));
                digitalReleaseTimers.delete(movement);
            }

            // CRITICAL FIX 1: Ensure active state is persistent, and release is registered.
            if (isCurrentlyActive === true) {
                movements[movement] = true; // State is active (Touched/Pressed)
            } else if (isCurrentlyActive !== wasPreviouslyActive) {
                movements[movement] = false; // State just became inactive (Released)
            }
        
        } else {
            // SCENARIO 2: ANALOG (Potentiometer) Inputs - Report state OR null
            if (potValues[i] < previousPotValues[i] - movementThreshold) {
                movements[movement] = false; // Movement decreases
            } else if (potValues[i] > previousPotValues[i] + movementThreshold) {
                movements[movement] = true; // Movement increases
            } else {
                movements[movement] = null; // No significant change
            }
        }
    }

    // 2. Update previous potentiometer values
    previousPotValues = potValues.slice(0, numPotentiometers);

    // 3. Merge and Queue Keys for Timed Forgetting
    const mergedMovements = { ...previousMovements, ...movements };
    const allMovementKeys = Object.values(labelMovements);

    for (const key of allMovementKeys) {
        
        if (mergedMovements[key] === undefined) {
            continue;
        }

        // 3a. Clean up Analog's 'null' values
        if (mergedMovements[key] === null) {
            delete mergedMovements[key];
            continue;
        }
        
        // 3b. Clean up Digital's 'false' values (Released/Inactive)
        const isDigitalKey = digitalParts.map(p => labelMovements[p]).includes(key);

        if (isDigitalKey && mergedMovements[key] === false) {
            // CRITICAL FIX 2: Allow the 'false' state to be returned, THEN set the timer.

            if (!digitalReleaseTimers.has(key)) {
                 // Set the timer to delete the key from previousMovements after the persistence time
                const timerId = setTimeout(() => {
                    delete previousMovements[key];
                    digitalReleaseTimers.delete(key);
                }, RELEASE_PERSISTENCE_MS); 
                
                digitalReleaseTimers.set(key, timerId);
            }
            
            // DO NOT delete mergedMovements[key]. We want 'false' to persist temporarily.
            // It will be saved into previousMovements in the return block below.
        }
    }
    
    // 4. Return Final State
    // If the merged state is different from the last state, return the new merged state.
    if (!objectsEqual(mergedMovements, previousMovements)) { 
        previousMovements = mergedMovements; // The 'false' state is now saved for 100ms
        return mergedMovements; 
    }

    // If there is no change, return null.
    return null; 
}

let cachedMovementConditions = null;
let previousActiveMovements = []; // Replaces previousPart and previousDirection
// Note: partMoving and directionMoving are obsolete and should be removed globally.
let movementBuffer = [];
let cachedMovePatterns;
let patternMovement = "none";
let movementResetTimer = null; // Stores the setTimeout ID

async function checkMovement() {
    let movements = handleMovement(); // Get current movement data

    // 1. Fetch movement conditions JSON file if not already cached
    if (!cachedMovementConditions) {
        try {
            cachedMovementConditions = await $.get(moveSource);
        } catch (error) {
            console.error('Error fetching movement conditions JSON:', error);
            return; // Exit if fetch fails
        }
    }
    
    // 2. Execution Entry Point: Process state change
    // We execute this if movements are available, regardless of the 'speaking' status.
    if (movements) {
        processMovementConditions(movements);
    }
    
    // --- Inner Processor Function ---
    function processMovementConditions(movements) {
        
        // Exit cleanly if movements is null/undefined or an empty object {}
        if (!movements || Object.keys(movements).length === 0) {
            return; 
        }
        
        // 1. Collect all currently active movements (currentActiveMovements is built here)
        let currentActiveMovements = [];

        cachedMovementConditions.forEach(condition => {
            let match = true;
            for (let key in condition.condition) {
                if (movements[key] !== condition.condition[key]) {
                    match = false;
                    break;
                }
            }

            if (match) {
                currentActiveMovements.push({
                    part: condition.partMoving, 
                    direction: condition.directionMoving
                });
            }
        });
        
        // 2. Prepare arrays for comparison
        const currentMovementsString = JSON.stringify(currentActiveMovements.sort((a, b) => (a.part + a.direction).localeCompare(b.part + b.direction)));
        const previousMovementsString = JSON.stringify(previousActiveMovements.sort((a, b) => (a.part + a.direction).localeCompare(b.part + b.direction)));

        // 3. Check if the set of active movements has changed (MUST RUN ALWAYS)
        if (currentMovementsString !== previousMovementsString) {
            
            // ACTION 1: Clear any existing reset timer, as a state change just occurred. (MUST RUN ALWAYS)
            if (movementResetTimer) {
                clearTimeout(movementResetTimer);
                movementResetTimer = null;
            }
            
            // --- DETERMINE NEW STATE AND TIMER ACTION ---
            
            if (currentActiveMovements.length === 0) {
                // SCENARIO A: Movement HAS stopped (transition to empty array)
                
                // Set the timer to perform the legacy variable reset after 2 seconds
                movementResetTimer = setTimeout(() => {
                    partMoving = "none";
                    directionMoving = "none";
                    console.log("--Movement Timer Reset: Legacy variables cleared.");
                }, 2000); 
                
                // Immediately update the multi-movement previous state to register the stop
                previousActiveMovements = currentActiveMovements;
                return; // Exit here. We registered the stop and set the timer.
            }
            
            // --- ONLY PROCEED WITH LOGGING/ACTIONS IF NOT SPEAKING ---
            if (!speaking) {
                // SCENARIO B: Movement HAS started/changed (currentActiveMovements is NOT empty)
                
                // Update legacy single-movement variables
                partMoving = currentActiveMovements[0].part;
                directionMoving = currentActiveMovements[0].direction;

                let logMessage = currentActiveMovements.map(m => m.part + " " + m.direction).join(" & ");
                console.log("--Movement: " + logMessage);
                
                if (noNarrative) {
                    //window.success_Sound.play();
                    //displayText("Avatar is doing: " + logMessage + ".");
                }
                
                // 4. Update the global previous state and track the sequence
                previousActiveMovements = currentActiveMovements;
                trackMovementSequences(currentActiveMovements); 
            }
            // If speaking is TRUE, the state is still updated above (previousActiveMovements), 
            // but we skip the logging/tracking/legacy variable update.
        } 
    }
}

			// Function to track movement sequences and compare them against patterns
			async function trackMovementSequences(currentActiveMovements) {
				const PRUNE_TIME_MS = 1500; // Time limit for a sequence step (1.5 seconds)
				const now = Date.now();
				
				// 1. Time-Based Pruning Logic
				while (movementBuffer.length > 0 && (now - movementBuffer[0].timestamp > PRUNE_TIME_MS)) {
					movementBuffer.shift(); // Remove the oldest entry
				}
				
				// 2. Normalize and check for duplicate states
				const normalizedSequence = currentActiveMovements.sort((a, b) => 
					(a.part + a.direction).localeCompare(b.part + b.direction)
				);
				const currentSequenceString = JSON.stringify(normalizedSequence);
				
				// 2a. Safely retrieve the state of the last entry
				const lastEntryStateString = movementBuffer.length > 0 
					? JSON.stringify(movementBuffer[movementBuffer.length - 1].state) 
					: null;

				// 2b. If the current state is the same as the last one, ignore it and exit early
				if (lastEntryStateString === currentSequenceString) {
					return; 
				}

				// 3. Push the new, unique state with a timestamp
				movementBuffer.push({ 
					state: normalizedSequence, 
					timestamp: now 
				});

				// 4. Pattern Matching Logic
				const patterns = await fetchJSONFile(movePatterns, cachedMovePatterns);
				
				// Create an array of only the states for the pattern checker
				const bufferStates = movementBuffer.map(entry => entry.state);

				for (const pattern of patterns) {
					// We pass only the 'state' arrays to the checkPatternInBuffer function
					if (checkPatternInBuffer(pattern.pattern, bufferStates)) { 
						window.complete_Sound.play();
						console.log(`--Pattern matched: ${pattern.patternName}`);
						patternMovement = pattern.patternName;
						
						// Clear the buffer after a match
						movementBuffer = [];
						setTimeout(resetVariables, 4000); 
						return;
					}
				}
			}
			function resetVariables(resetAll = true) {
				// Clear the new multi-state variable
				previousActiveMovements = [];

				// The old partMoving/directionMoving assignments are removed.

				// Clear the pattern variable
				if (resetAll) {
					patternMovement = "none";
				}
			}

			// Function to check if a pattern exists in the movement buffer
			function checkPatternInBuffer(pattern, buffer) {
				if (buffer.length < pattern.length) { 
					return false;
				}
				
				const bufferSlice = buffer.slice(-pattern.length); 
				
				for (let i = 0; i < pattern.length; i++) {
					const requiredMovement = pattern[i]; 
					const currentBufferState = bufferSlice[i]; // Array of ALL active movements
					
					let foundMatch = false;
					
					// Check if the required single movement is PRESENT in the multi-movement state
					for (const activeMovement of currentBufferState) {
						// Note: Uses 'part' and 'direction' from the buffer's activeMovement objects
						if (activeMovement.part === requiredMovement.partMoving && 
							activeMovement.direction === requiredMovement.directionMoving) {
							foundMatch = true;
							break; 
						}
					}

					if (!foundMatch) {
						return false; // Pattern step not found in the buffer state
					}
				}
				return true;
			}

			let cachedPatterns; // Variable to cache the fetched patterns data
			async function fetchMovementPatterns() {
				try {
					if (cachedPatterns) {
						// If data is already cached, return it immediately
						return cachedPatterns;
					} else {
						// If data is not cached, fetch it from the server
						const patterns = await $.get(movePatterns);
						cachedPatterns = patterns; // Cache the fetched data
						return patterns;
					}
				} catch (error) {
					console.error(error);
					return []; // Return an empty array in case of error
				}
			}

			var timeoutID; // Variable to hold the timeout ID.
			var previousMessage = ""; // Variable to store the previous message
			var previousLatitude;
			var previousLongitude;
			var previousPartMoving;
			var previousDirectionMoving;
			var timeOfDay;

			var fullMessage;
			var messageID = ""; // Global variable to store the message ID.
			var oldMessageID ="";
			var messageID_tmp = "";
			var playAction = false;

			function displayText(message) {
				var messageDisplayDiv = document.getElementById("messageDisplayDiv");
				var delimiterIndex = message.indexOf("/"); // Find the index of the first delimiter "/"

				if (delimiterIndex !== -1) { // Check if the first delimiter exists
					messageID_tmp = message.substring(0, delimiterIndex); // Store the message ID
					console.log("--Passage: "+messageID_tmp);
					var secondDelimiterIndex = message.indexOf("/", delimiterIndex + 1); // Find the index of the second delimiter "/"

					if (secondDelimiterIndex !== -1 && secondDelimiterIndex !== delimiterIndex) { // Check if the second delimiter exists
						var thirdDelimiterIndex = message.indexOf("/", secondDelimiterIndex + 1); // Find the index of the third delimiter "/"

						if (thirdDelimiterIndex !== -1) { // Check if the third delimiter exists
							var fourthDelimiterIndex = message.indexOf("/", thirdDelimiterIndex + 1); // Find the index of the fourth delimiter "/"

							var fullMessage = message.substring(delimiterIndex + 1, secondDelimiterIndex).trim(); // Extract the message text between the first and second delimiters
							var audioSoundscape = message.substring(secondDelimiterIndex + 1, thirdDelimiterIndex).trim(); // Extract the audioSoundscape variable between the second and third delimiters

							clearTimeout(timeoutID);
							speakMessage(fullMessage);
							updateDisplay(fullMessage);

							if (audioSoundscape !== "") {
								window[audioSoundscape + "_Sound"].play(); // Play the corresponding audio based on the audioSoundscape variable if it is not empty
							}

							if (fourthDelimiterIndex !== -1) { // If the fourth delimiter exists
								var functionToEval = message.substring(thirdDelimiterIndex + 1, fourthDelimiterIndex).trim(); // Extract the function between the third and fourth delimiters
								try {
									eval(functionToEval); // Run the function using eval()
								} catch (error) {
									console.error("Error executing displayText function: " + error);
								}
							}
						} else { // Handle the case where there's no third delimiter
							var fullMessage = message.substring(delimiterIndex + 1, secondDelimiterIndex).trim(); // Extract the message text between the first and second delimiters
							var audioSoundscape = message.substring(secondDelimiterIndex + 1).trim(); // Extract the audioSoundscape variable after the second delimiter

							clearTimeout(timeoutID);
							speakMessage(fullMessage);
							updateDisplay(fullMessage);
							if (audioSoundscape !== "") {
								window[audioSoundscape + "_Sound"].play(); // Play the corresponding audio based on the audioSoundscape variable if it is not empty
							}
						}
					} else { // Handle the case where there's no second delimiter
						var fullMessage = message.substring(delimiterIndex + 1).trim(); // Extract the message text after the first delimiter
						clearTimeout(timeoutID);
						speakMessage(fullMessage);
						updateDisplay(fullMessage);
					}
				} else { // Handle the case where there's no delimiter at all
					var fullMessage = message.trim(); // The full message is the entire input
					clearTimeout(timeoutID);
					speakMessage(fullMessage);
					updateDisplay(fullMessage);
				}
			}

			function updateDisplay(displayMessage) {
				try {
					// Ensure the element exists
					if (!messageDisplayDiv) {
					console.error("messageDisplayDiv element not found");
					return;
					}

					// Clear existing timeout
					if (timeoutID) {
					clearTimeout(timeoutID);
					}

					// Update the message and toggle visibility
					if (displayMessage.trim() !== "") {
					messageDisplayDiv.textContent = displayMessage; // Update text
					messageDisplayDiv.classList.add("visible"); // Add visible class for fade-in
					} else {
					messageDisplayDiv.classList.remove("visible"); // Remove visible class for fade-out
					}

					// Adjust font size
					const maxHeight = 100; // Maximum height
					adjustFontSizeToFit(messageDisplayDiv, maxHeight);

					// Recursive polling for auto-hiding the text.
					function pollForSpeaking() {
						if (!speaking) {
							messageDisplayDiv.classList.remove("visible"); // Trigger fade-out
							messageDisplayDiv.textContent = ""; // Clear the text
						} else {
							timeoutID = setTimeout(pollForSpeaking, 500); // Check again in 500ms
						}
					}

					timeoutID = setTimeout(pollForSpeaking, 8000); // Start polling after initial delay
					} catch (error) {
						console.error("An error occurred in updateDisplay:", error);
					}
				}


			// Function to adjust the font size dynamically to fit within the maxHeight (in vh)
			function adjustFontSizeToFit(div, maxHeight) {
				const viewportHeight = window.innerHeight; // Get the current viewport height in px
				const divHeight = (viewportHeight * maxHeight) / 100; // Convert maxHeight (in vh) to pixels

				// Set the max height of the DIV in pixels
				div.style.maxHeight = divHeight + "px";

				// Get the current font size in pixels
				let fontSize = parseInt(window.getComputedStyle(div).fontSize, 10);

				// Set an initial font size (in px) based on the viewport height
				let currentHeight = div.scrollHeight;

				// Adjust the font size to ensure the content fits within the max height of the div
				while (currentHeight > divHeight && fontSize > 10) { // 10px is the minimum font size
					fontSize -= 1;
					div.style.fontSize = fontSize + "px";
					currentHeight = div.scrollHeight; // Get the updated height after resizing
				}
			}

			async function fetchJSONFile(filename, cachedVariable) {
				try {
					if (!cachedVariable) {
						const response = await fetch(filename);
						if (!response.ok) {
							throw new Error('Network response was not ok');
						}
						const jsonData = await response.json(); // Fetch JSON data
						cachedVariable = jsonData; // Cache the fetched JSON data in the specified variable
						return jsonData;
					} else {
						return cachedVariable; // Return cached data if available
					}
				} catch (err) {
					console.error('Error fetching JSON file: ', err);
					return null;
				}
			}

			let cachedSentences;

			// Variable to store the last spoken message
			let lastSpokenMessage = '';
			let speaking = false;

			const transliterationMap = {
				'á': 'a', 'à': 'a', 'ä': 'a', 'ã': 'a', 'â': 'a', 'å': 'a', 'č': 'tch','æ':'ae',
				'ç': 'c', 'é': 'e', 'è': 'e', 'ë': 'e', 'ê': 'e', 'í': 'i', 'ì': 'i',
				'ï': 'i', 'î': 'i', 'ñ': 'ny', 'ó': 'o', 'ò': 'o', 'ö': 'o', 'õ': 'o', 'ø':'oe',
				'ô': 'o', 'ú': 'u', 'ù': 'u', 'ü': 'u', 'û': 'u', 'ý': 'y', 'ÿ': 'y',
				'š': 'sh', 'ž': 'zh', 'ř': 'r', 'ů': 'u', 'ď': 'd', 'ť': 't', 'ň': 'n',
				'Á': 'A', 'À': 'A', 'Ä': 'A', 'Ã': 'A', 'Â': 'A', 'Å': 'A', 'Č': 'TCH', 'Æ':'AE',
				'Ç': 'C', 'É': 'E', 'È': 'E', 'Ë': 'E', 'Ê': 'E', 'Í': 'I', 'Ì': 'I',
				'Ï': 'I', 'Î': 'I', 'Ñ': 'NY', 'Ó': 'O', 'Ò': 'O', 'Ö': 'O', 'Õ': 'O', 'Ø':'OE',
				'Ô': 'O', 'Ú': 'U', 'Ù': 'U', 'Ü': 'U', 'Û': 'U', 'Ý': 'Y', 'Ÿ': 'Y',
				'Š': 'SH', 'Ž': 'ZH', 'Ř': 'R', 'Ů': 'U', 'Ď': 'D', 'Ť': 'T', 'Ň': 'NY'
			};

			function transliterate(text) {
				return text.split('').map(char => transliterationMap[char] || char).join('');
			}

			let currentSound = null;

			function speakMessage(fullMessage) {
				console.log("--Speaking: "+fullMessage);
				if (speakFancy) {
					speakMessage_azure(fullMessage);
				} else {
					speakMessage_coqui(fullMessage);
				}
			}

			async function speakMessage_azure(fullMessage) {
			// THIS FUNCTION USES AZURE!
			// Transliterate the message to contain only English alphabet characters
				const transliteratedMessage = transliterate(fullMessage);

			// Check if the message is the same as the last spoken message
			if (transliteratedMessage === lastSpokenMessage) {
				console.log("Message already spoken.");
				return; // Exit the function without speaking again
			}

			if (transliteratedMessage === "") {
				console.log("Empty text, message ignored.");
				return;
			}

			// Azure TTS API details
			const endpoint = "https://germanywestcentral.tts.speech.microsoft.com/cognitiveservices/v1";
			const subscriptionKey = "9PhQZhVP3ZRybebW3qaOiHU0EZc6eKmZGbP74vpuM2wqradXDdc2JQQJ99BDACPV0roXJ3w3AAAYACOGCcy5";
			const voiceName = "en-GB-SoniaNeural"; // Use en-GB-SoniaNeural
			const outputFormat = "audio-24khz-160kbitrate-mono-mp3"; // Output format for audio

			// Construct SSML request body
			const ssml = `
				<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-GB'>
					<voice name='${voiceName}'>
					<prosody volume="x-loud">
						${transliteratedMessage}
						</prosody>
					</voice>
				</speak>
			`;

			try {
				// Define the headers for the API request
				const headers = {
					"Ocp-Apim-Subscription-Key": subscriptionKey,
					"Content-Type": "application/ssml+xml",
					"X-Microsoft-OutputFormat": outputFormat,
					"User-Agent": "Azure-TTS-JS",
				};

				// Fetch function with retries
				async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
					for (let attempt = 1; attempt <= retries; attempt++) {
						try {
							const response = await fetch(url, options);
							if (response.ok) {
								return response;
							} else {
								console.log(`Attempt ${attempt} failed. Retrying in ${delay / 1000} seconds...`);
							}
						} catch (error) {
							console.log(`Attempt ${attempt} encountered an error: ${error.message}`);
						}
						await new Promise((resolve) => setTimeout(resolve, delay));
					}
					throw new Error(`Failed to fetch after ${retries} attempts`);
				}

				// Make a fetch request to the Azure TTS API
				const response = await fetchWithRetry(endpoint, {
					method: "POST",
					headers: headers,
					body: ssml,
				});

				// Convert response to a Blob for audio playback
				const audioBlob = await response.blob();
				const audioUrl = URL.createObjectURL(audioBlob);

				// Stop the current sound if it is playing
				if (currentSound) {
					console.log("Stopping current text");
					currentSound.stop();
					currentSound.unload();
				}

				// Create a new Howler.js sound object
				const sound = new Howl({
					src: [audioUrl],
					format: ["mp3"], // Specify the format here
					html5: true, // Force HTML5 audio playback
					onplay: () => {
						console.log(deviceName + " currently speaking");
						speaking = true;
						messageID = messageID_tmp;
						oldMessageID = messageID;
						lastSpokenMessage = transliteratedMessage;
						playAction = true;
					},
					onend: () => {
						if (playAction) {
							setTimeout(() => {
								window.notification_Sound.play(); // Play the notification sound after a delay
								console.log(deviceName + " end speaking");
								speaking = false;
								sound.unload(); // Unload the audio object to free up resources
								playAction = false; // Reset playAction to false
							}, 500); // Delay of 500 milliseconds
						}
						currentSound = null; // Reset currentSound when finished
					},
					onloaderror: (id, err) => {
						console.error("Audio playback error:", err);
						speaking = false;
						sound.unload(); // Unload the audio object to free up resources
						currentSound = null; // Reset currentSound on error
					},
				});

				// Set the current sound to the new sound object
				currentSound = sound;

				sound.play();

				// Trigger the "unlock" event if necessary
				if (Howler.ctx.state === "suspended") {
					Howler.ctx.resume();
				}
			} catch (error) {
				speaking = false; // Reset speaking flag
				console.error("Error with TTS API:", error);
			}
			}


			async function speakMessage_coqui(fullMessage) {
				//THIS FUNCTION USES COQUI_TTS
				// Transliterate the message to contain only English alphabet characters
				const transliteratedMessage = transliterate(fullMessage);

				// Check if the message is the same as the last spoken message
				if (transliteratedMessage === lastSpokenMessage) {
					console.log("Message already spoken.");
					return; // Exit the function without speaking again
				}

				if (transliteratedMessage === "") {
					console.log("Empty text, message ignored.");
					return;
				}

				const encodedMessage = encodeURIComponent(transliteratedMessage);
				const url = `https://s4us-tts.fi.muni.cz:5002/api/tts?text=${encodedMessage}&speaker_id=&style_wav=&language=en`;

				async function fetchWithRetry(url, retries = 3, delay = 1000) {
					for (let attempt = 1; attempt <= retries; attempt++) {
						try {
							const response = await fetch(url);
							if (response.ok) {
								return response;
							} else {
								console.log(`Attempt ${attempt} failed. Retrying in ${delay / 1000} seconds...`);
							}
						} catch (error) {
							console.log(`Attempt ${attempt} encountered an error: ${error.message}`);
						}
						await new Promise(resolve => setTimeout(resolve, delay));
					}
					throw new Error(`Failed to fetch after ${retries} attempts`);
				}

				try {
					// Make a fetch request to the Coqui TTS API
					const response = await fetchWithRetry(url);

					// Convert response to a Blob for audio playback
					const audioBlob = await response.blob();
					const audioUrl = URL.createObjectURL(audioBlob);

					// Stop the current sound if it is playing
					if (currentSound) {
						console.log("Stopping current text");
						currentSound.stop();
						currentSound.unload();
					}

					// Create a new Howler.js sound object
					const sound = new Howl({
						src: [audioUrl],
						format: ['wav'], // Specify the format here
						html5: true, // Force HTML5 audio playback
						onplay: () => {
							console.log(deviceName +" currently speaking");
							speaking = true;
							messageID = messageID_tmp;
							oldMessageID = messageID;
							lastSpokenMessage = transliteratedMessage;
							playAction = true;
						},
						onend: () => {
							if (playAction) {
								setTimeout(function() {
									window.notification_Sound.play(); // Play the notification sound after a delay
									console.log(deviceName + " end speaking");
									speaking = false;
									sound.unload(); // Unload the audio object to free up resources
									playAction = false; // Reset playAction to false

								}, 500); // Delay of 2000 milliseconds (2 seconds)
							}
							currentSound = null; // Reset currentSound when finished
						},
						onloaderror: (id, err) => {
							console.error("Audio playback error:", err);
							speaking = false;
							sound.unload(); // Unload the audio object to free up resources
							currentSound = null; // Reset currentSound on error
						},
					});

					// Set the current sound to the new sound object
					currentSound = sound;

					sound.play();

					// Trigger the "unlock" event if necessary
					if (Howler.ctx.state === "suspended") {
						Howler.ctx.resume();
					}
				} catch (error) {
					speaking = false; // Reset speaking flag
					console.error("Error with TTS API:", error);
				}
			}

			let weatherDescription = null;

			var noNarrative =true;
			var speakFancy = false;

			var previousTagID = 0 // Variable to store the previous tagID

			let cachedTagInfo;
			async function readTag() {
				try {
					if (tagID === previousTagID || tagID === 0 || speaking) {
						// If tagID is the same as the previous one or is 0, do nothing
						return;
					} else {
						// Fetch tag information asynchronously
						const tagInfo = await fetchJSONFile(tagSource, cachedTagInfo);

						if (tagInfo && tagInfo.tags.hasOwnProperty(tagID)) {
							// Update previousTagID to the current tagID
							previousTagID = tagID;
							window.success_Sound.play();
							console.log("Tag "+ tagID + " read.");

							// Retrieve tag information based on tagID
							const tagData = tagInfo.tags[tagID];

							// Execute function specified in the JSON
							if (tagInfo.tags[tagID].function) {
								eval(tagInfo.tags[tagID].function);
							}

							// Update variables based on fetched tagData
							if (tagData.variable && typeof tagData.boolean === 'boolean') {
								// Dynamically update variables based on tagData
								window[tagData.variable] = tagData.boolean;
							}
							displayText(tagData.displayText);

						} else {
							window.alert_Sound.play();
							console.error('Tag '+tagID+' information not found.');
							return;
						}
					}
				} catch (err) {
					console.error('Error reading tag', err);
				}
			}

			let cachedCheckpoints;
			let lastCheckedIndex = 0; // Initialize the index of the last checked key
			let currentCheckpoint = "none";
			let chkPointDistance = [0];

			let previousCheckpointKey = null;
			let previousChkPointDistance = null;
			let previousCheckpoint = null; // Define previousCheckpoint as a global variable

			async function checkCheckpoints() {
				const radius = 12; // 12 meters radius
				let checkpointsKey = deviceName === "hachi_BT" ? "hachi_checkpoints" : "avatar_checkpoints";

				const locations = await fetchJSONFile(checkpointsSource, cachedCheckpoints);

				if (Array.isArray(locations) && locations.length > 0) {
					const checkpoints = locations[0][checkpointsKey];

					if (typeof checkpoints === 'object' && checkpoints !== null) {
						const checkpointKeys = Object.keys(checkpoints);

						if (lastCheckedIndex < checkpointKeys.length) {
							const currentCheckpointKey = checkpointKeys[lastCheckedIndex];
							const checkpointSet = checkpoints[currentCheckpointKey];
							chkPointDistance = [];

							for (const checkpoint of checkpointSet) {
								const distance = calculateDistance(latitude, longitude, checkpoint.latitude, checkpoint.longitude);
								chkPointDistance.push(distance.toFixed(2));

								if (distance <= radius && checkpoint.text !== previousCheckpoint) {
									console.log('Checkpoint reached:', checkpoint.text);
									currentCheckpoint = checkpoint.text;
									window.success_Sound.play();
									lastCheckedIndex++;
									previousCheckpoint = checkpoint.text; // Update previous checkpoint text
									chkPointDistance = [];
									return;
								}
							}

							const isCheckpointKeyChanged = previousCheckpointKey !== currentCheckpointKey;
							const isChkPointDistanceChanged = JSON.stringify(previousChkPointDistance) !== JSON.stringify(chkPointDistance);

							if ((isCheckpointKeyChanged || isChkPointDistanceChanged) && !listenClient && interactionMode !== "_load") {
								//console.log('Current Checkpoint Set:', currentCheckpointKey, 'Distances to all checkpoints:', chkPointDistance);
								previousCheckpointKey = currentCheckpointKey;
								previousChkPointDistance = JSON.parse(JSON.stringify(chkPointDistance));
							}
						} else {
							//console.log("No more checkpoint sets to check.");
						}
					}
				}
			}

			function setupColors() {
				lineColors[0] = color(204, 204, 0); // Dark Yellow
				lineColors[1] = color(204, 204, 0); // Dark Yellow
				lineColors[2] = color(255, 0, 0); // Red
				lineColors[3] = color(204, 204, 0); // Dark Yellow
				lineColors[4] = color(204, 204, 0); // Dark Yellow
				lineColors[5] = color(0, 255, 0); // Bright Green
				lineColors[6] = color(0, 255, 0); // Bright Green
				lineColors[7] = color(0, 128, 0); // Grass Green
				lineColors[8] = color(0, 128, 0); // Grass Green
				lineColors[9] = color(255, 0, 0); // Red
				lineColors[10] = color(204, 204, 0); // Dark Yellow
			}
			function setupBackgroundColors() {
				backgroundColors[0] = color(0, 0, 0); // 0% black
				backgroundColors[1] = color(0, 0, 0); // 0% black
				backgroundColors[2] = color(0, 0, 0, 200); // 90% black
				backgroundColors[3] = color(0, 0, 0, 230); // 75% black
				backgroundColors[4] = color(0, 0, 0, 230); // 75% black
				backgroundColors[5] = color(0, 0, 0, 128); // 60% black
				backgroundColors[6] = color(0, 0, 0, 128); // 60% black
				backgroundColors[7] = color(0, 0, 0, 230); // 75% black
				backgroundColors[8] = color(0, 0, 0, 230); // 75% black
				backgroundColors[9] = color(0, 0, 0, 200); // 90% black
				backgroundColors[10] = color(0, 0, 0, 128); // 60% black
			}
		</script>

		<script type="module">
			import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js'
			import  { getDatabase, ref, set, onValue, off, update } from 'https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js'

			// Your Firebase configuration
			const firebaseConfig = {
				apiKey: "AIzaSyDuRvVnlDRGlQoDcWg6SlXR9lr4Xlz1PX4",
				authDomain: "thejungle-33676.firebaseapp.com",
				databaseURL: "https://thejungle-33676-default-rtdb.europe-west1.firebasedatabase.app",
				projectId: "thejungle-33676",
				storageBucket: "sthejungle-33676.firebasestorage.app",
				messagingSenderId: "1078745256439",
				appId: "1:1078745256439:web:6bb68e64e3a526fb061ef2"
			};

			// Initialize Firebase
			const app = initializeApp(firebaseConfig);

			// Reference to your Firebase Realtime Database
			const database = getDatabase(app);

			// Store previous values of synced variables
			let prevLatitude = null;
			let prevLongitude = null;
			let prevCurrentCheckpoint = null;
			let prevMovement = null;
			let prevTagInteraction = null;
			let prevHeading = null;
			let prevStatus = null;
			let prevSpeed = null;
			let prevSpeaking = null
			let prevPartMoving = null;
			let prevDirectionMoving = null;
			let prevBlueToothStatus = null;

			// Function to write data to the database
			function writeToDatabase() {
			    // Check if variables are not null or empty
			    if (latitude && longitude && currentCheckpoint) {
			        // Check if variables have changed since the last write operation
			     if (latitude !== prevLatitude ||
			         longitude !== prevLongitude ||
			         currentCheckpoint !== prevCurrentCheckpoint ||
			         patternMovement !== prevMovement ||
			         tagID !== prevTagInteraction ||
					 blueToothStatus !== prevStatus ||
					 speaking !== prevSpeaking ||
					 directionMoving !== prevDirectionMoving ||
					 partMoving !==prevPartMoving ||
					 speed !== prevSpeed ||
					 blueToothStatus !== prevBlueToothStatus ||
			         directionText !== prevHeading) {

			            // Update previous values
						prevPartMoving = partMoving;
						prevDirectionMoving = directionMoving;
			            prevLatitude = latitude;
			            prevLongitude = longitude;
			            prevCurrentCheckpoint = currentCheckpoint;
						prevMovement = patternMovement;
						prevTagInteraction = tagID;
						prevHeading = directionText;
						prevStatus = blueToothStatus;
						prevSpeed = speed;
						prevSpeaking = speaking;
			            // Determine the database name based on the deviceName
			            const databaseName = (deviceName === 'hachi_BT') ? 'hachi_data' : 'avatar_data';

			            // Determine the variable names based on the deviceName
			            const latitudeVar = (deviceName === 'hachi_BT') ? 'hachi_latitude' : 'avatar_latitude' ;
			            const longitudeVar = (deviceName === 'hachi_BT') ? 'hachi_longitude' : 'avatar_longitude';
						const headingVar = (deviceName === 'hachi_BT') ? 'hachi_heading' : 'avatar_heading';
			            const checkpointVar = (deviceName === 'hachi_BT') ? 'hachi_checkpoint' :'avatar_checkpoint' ;
						const checkDistVar = (deviceName === 'hachi_BT') ? 'hachi_checkpoint_dist' : 'avatar_checkpoint_dist';
						const movementVar = (deviceName === 'hachi_BT') ? 'hachi_movement' :'avatar_movement' ;
						const partMovementVar = (deviceName === 'hachi_BT') ? 'hachi_part_mov' :'avatar_part_mov' ;
						const dirMovementVar = (deviceName === 'hachi_BT') ? 'hachi_part_dir' :'avatar_part_dir' ;
						const tagInteractionVar = (deviceName === 'hachi_BT') ? 'hachi_tag' :'avatar_tag' ;
						const statusVar = (deviceName === 'hachi_BT') ? 'hachi_status' :'avatar_status' ;
						const speedVar = (deviceName === 'hachi_BT') ? 'hachi_speed' :'avatar_speed' ;
						const speakingVar = (deviceName === 'hachi_BT') ? 'hachi_narrating' :'avatar_narrating' ;
						const currentPsgVar = (deviceName === 'hachi_BT') ? 'hachi_current_passage' :'avatar_current_passage' ;
						const nameVar = (deviceName === 'hachi_BT') ? 'story_name' :'story_name' ;

			            // Write variables to the database
			            update(ref(database, databaseName), {
			                [latitudeVar]: latitude,
			                [longitudeVar]: longitude,
							[headingVar]: directionText,
			                [checkpointVar]: currentCheckpoint,
							[checkDistVar]: chkPointDistance,
							[movementVar]: patternMovement,
							[nameVar]: characterName,
							[partMovementVar]: partMoving,
							[dirMovementVar]: directionMoving,
							[tagInteractionVar]: tagID,
							[statusVar]: blueToothStatus,
							[speedVar]: speed.toFixed(2),
							[speakingVar]: messageID+speaking,
							[currentPsgVar]: messageID
			            }).then(() => {
			                //console.log("Variables written to the database successfully!");
			            }).catch((error) => {
			                console.error("Error writing variables to the database:", error);
			            });
			        } else {
			            //console.log("Variables have not changed. Data not written to the database.");
			        }
			    } else {
			        //console.log("One or more variables are null or empty. Data not written to the database.");
			    }
			}

			var other_latitude=null;
			var other_longitude=null;
			let previousPassage = ''; // Initialize previous passage value
			let previousTagID = ''; // Initialize previous tag value

			// Function to x data from the database
			function readFromDatabase(deviceName) {
				// Read from the other database based on deviceName
				const otherDatabaseName = (deviceName === 'hachi_BT') ? 'avatar_data': 'hachi_data';
				const otherLatitudeVar = (deviceName === 'hachi_BT') ? 'avatar_latitude' : 'hachi_latitude';
				const otherLongitudeVar = (deviceName === 'hachi_BT') ? 'avatar_longitude' : 'hachi_longitude' ;
				const databaseName = (deviceName === 'hachi_BT') ? 'hachi_data' : 'avatar_data';
				const myPassage = (deviceName === 'hachi_BT') ? 'hachi_passage' :'avatar_passage' ;
				const myStreet = (deviceName === 'hachi_BT') ? 'hachi_street' :'avatar_street' ;
				const myTag = (deviceName === 'hachi_BT') ? 'hachi_tag' :'avatar_tag' ;

				// Subscribe to real-time updates for variables from the other database
				onValue(ref(database, otherDatabaseName), (snapshot) => {
					const otherData = snapshot.val();
					if (otherData) {
						other_latitude = otherData[otherLatitudeVar];
						other_longitude = otherData[otherLongitudeVar];
						distEachOther = calculateDistance(latitude, longitude, other_latitude, other_longitude);
						//console.log("Variables read from the other database successfully!");
					} else {
						console.log("No data found in the other database.");
					}
				});

				// Subscribe to real-time updates for variables from own database
				onValue(ref(database, databaseName), (snapshot) => {
				const myData = snapshot.val();
				if (myData) {
					const passage = myData[myPassage];
					//console.log(databaseName);
					if (passage !== previousPassage) { // Compare with previous passage
						//console.log(String(passage));
						displayText(String(passage));
						previousPassage = passage; // Update previous passage
					}
					streetName = myData[myStreet];

					// Compare myTag with previousTag and set speakFancy
					const tag = myData[myTag];
					if (listenClient) {
						if (tag !== previousTagID) {
							if (tag === 14) {
								speakFancy = false;  // Set speakFancy to false when myTag is 14
								displayText("Using Coqui's Voice.");
								console.log("Coqui TTS in listening mode");
							} else if (tag === 15) {
								speakFancy = true;   // Set speakFancy to true when myTag is 15
								displayText("Using Azure's Voice.");
								console.log("Azure TTS in listening mode");
							}
							previousTagID = tag; // Update previousTag
						}
				}
				} else {
					console.log("No data found in the own database.");
				}
			});
			}

			function toggleDeviceName2() {
				var checkbox = document.getElementById("hachiCheckbox");
				const databaseName = (deviceName === 'hachi_BT') ? 'avatar_data' : 'hachi_data';
				if (checkbox.checked) {
					off(ref(database, databaseName));
					readFromDatabase(deviceName); // Read data after writing
					console.log("Reading from: " + databaseName);

				} else {
					off(ref(database, databaseName));
					readFromDatabase(deviceName); // Read data after writing
					console.log("Reading from: "+databaseName);

				}
			}

			let hideTimeout; // Variable to store the timeout ID

			function toggleListening() {
				const toggleSwitch = document.getElementById('toggleSwitch');

				deviceName = toggleSwitch.checked ? "hachi_BT" : "avatar_BT";
				const databaseName = deviceName === 'hachi_BT' ? 'avatar_data' : 'hachi_data';

				// Mapping object for deviceName to characterName
				const deviceToCharacter = {'hachi_BT': 'Hachi','avatar_BT': 'Buro'};

				// Get characterName from the mapping object, default to 'Unknown' if not found
				const characterName = deviceToCharacter[deviceName] || 'Unknown';

				let toggleState = toggleSwitch.checked;
				// Listen for toggle changes and update the toggleState variable
				toggleSwitch.addEventListener('change', () => {
					toggleState = toggleSwitch.checked;
				});

				// Clear any existing timeout to reset the timer
				if (hideTimeout) {
					clearTimeout(hideTimeout);
				}

				// Set a new timer to hide the top-section div after 5 seconds
				hideTimeout = setTimeout(() => {
					const topSection = document.querySelector('.top-section');
					if (topSection) {
						off(ref(database, databaseName));
						readFromDatabase(deviceName);
						interactionMode="_lst";
						topSection.style.display = 'none';
						currentLocation.style.display = 'none';
						hachiCheckboxContainer.style.display = 'none';

						const avatarCanvas = document.getElementById('avatarCanvas');  // Select the element with ID 'avatarCanvas'
						if (avatarCanvas) {
							const avatarBTdiv = document.getElementById('avatarBTdiv');
							if (avatarBTdiv) {
								avatarBTdiv.remove(); // Remove the div with the ID 'avatarBTdiv'
							}
							avatarCanvas.innerHTML = `
								<div class="center-wrapper">
									<span class="material-symbols-outlined hearing-icon">hearing</span>
									<span id="loading-text"> Listening ${characterName}'s Story</span>
								</div>
							`; // Replace the content
							// Once the timeout happens, check the toggleState and apply the color
							const hearingIcon = document.querySelector('.hearing-icon');
							if (hearingIcon) {
								hearingIcon.style.color = toggleState ? '#4caf50' : '#0082fc'; // Apply the color based on toggleState
							}
						}
						displayText("Listening as " + characterName + ".");
						console.log("Listening as: "+ deviceName + ".");
						window[characterName + "_Sound"].play();
						bgm_Sound.play();
					}
				}, 5000);
			}

			let hasRun = false; // Flag to ensure the block runs only once
			setInterval(() => {
				if (listenClient === false ){
					writeToDatabase();
				}
				if (isConnected === true && listenClient === false && !hasRun){
					readFromDatabase(deviceName); // Read data after writing,
					hasRun = true;
				}
			}, 200);

			document.addEventListener('DOMContentLoaded', function() {
				var listenHachi = document.getElementById("hachiCheckbox");
				listenHachi.addEventListener('click', function() {
					toggleDeviceName2();
				});

				var listenCheckbox = document.getElementById("toggleSwitch");
				listenCheckbox.addEventListener('click', function() {
					toggleListening();
				});
			});

			//Log window closure
			window.addEventListener('beforeunload', function (event) {
				console.log('End of session');
			});
		</script>
	</body>
</html>
